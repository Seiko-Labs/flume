---
title: Overview
id: overview
---

## The Problem

As most apps grow and mature, developers are often faced with an important problem: How to present a user-interface to end-users for customizing business logic. Solving this problem gives rise to a large number of complex, bespoke UIs. This problem becomes especially apparent in apps designed to serve a wide variety of users with unique business logic needs. Flume helps developers standardize logic editing around a standard (albeit, customizable) user interface: a node editor.

## Why a Node Editor?

One could argue that node editors have become a standard for visual logic editing. They allow for a wide variety of logical structures, but also allow developers to define their own "guardrails" to prevent end-users from defining invalid logic. In many applications, node editors have become a common compromise between UI complexity, and full logical expression. Following are just a few examples of node editors found in popular desktop applications (Flume itself is inspired by many of these node-editor implementations).

![A grid of node editor screenshots including, Blender, Unreal Engine, Substance Designer, and GoDot](/img/example_editors.png)

## Logic Extraction

There are many existing tools for modeling logic in a graph-like structure, however, most of these tools are for documentation or planning purposes. Flume provides a node editor for modeling logic, but also a robust toolset for executing that logic at runtime. This works by allowing developers to extract their business logic out of their code and into JSON "graphs", which represent a set of logical instructions. These logic graphs are much more portable than hardcoded logic, and enables the same set of logic to be executed in entirely different environments.

Flume makes this logic extraction possible not just for developers, but in many cases, end-users. Many applications suffer from "feature-flag" bloat, where developers are frequently handwriting different logical paths for different customers, and then turning them on and off per customer. Flume can help alleviate this common problem by empowering users to edit their own business logic.

As a side benefit, putting complex business logic into the hands of users, frees developers from the complexity of maintaining complex logic in code. This reduces the surface area for bugs and can also make defining business logic more accessible for non-programmers in your organization.

Additionally, because business logic can now be stored as JSON structures in your database, logic can be swapped out in your application remotely without requiring a new build of your application's code.

## Summary

Flume aims to be a lightweight toolset for solving these common problems. Continue on to the [next section](/docs/anatomy) to learn more about how your business logic can be stored and executed as JSON graphs.
